# Работа с частью списка 

# В главе 3 вы узнали, как обращаться к отдельным элементам списка, а в этой мы занимались перебором всех его элементов. 
# Можно работать и с конкретным подмножеством элементов списка; в Python такие подмножества называются срезами (slices).

# Нарезка списков 

# Чтобы создать срез списка, следует задать индексы первого и последнего элементов, 
# с которыми вы намереваетесь работать. Как и в случае с функцией range(), Python 
# останавливается на элементе, предшествующем второму индексу. Например, чтобы вывести 
# первые три элемента списка, запросите индексы с 0 по 3 и получите элементы 0, 1 и 2.
# В следующем примере используется список игроков команды:

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[0:3])
print()

# Здесь выводится часть списка. Вывод сохраняет структуру списка, но содержит только первых трех игроков:
# ['charles', 'martina', 'michael']

# Подмножество может содержать любую часть списка. Например, чтобы ограничиться вторым, третьим и четвертым элементами списка, 
# создайте срез, который начинается с индекса 1 и заканчивается на индексе 4:

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[1:4])
print()

# На этот раз срез начинается с элемента 'martina' и заканчивается элементом 'florence':
# ['martina', 'michael', 'florence']

# Если первый индекс среза не указан, то Python автоматически начинает срез от начала списка:

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[:4])
print()

# Без начального индекса Python берет элементы от начала списка:
#['charles', 'martina', 'michael', 'florence']

#Аналогичный синтаксис работает и для срезов, содержащих конец списка. Например, 
# если вам нужны все элементы с третьего до последнего, то начните с индекса 2 и не указывайте второй индекс:

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[2:])
print()

# Python возвращает все элементы с третьего до конца списка:
# ['michael', 'florence', 'eli']

# Этот синтаксис позволяет вывести все элементы от любой позиции до конца списка независимо от его длины.
#  Вспомните, что отрицательный индекс возвращает элемент, находящийся на определенном расстоянии от конца списка;
#  следовательно, вы можете получить любой срез от конца списка. Например, чтобы отобрать последних трех игроков из списка, 
#  используйте срез players[–3:]:

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[-3:])
print()

# Программа выводит имена трех последних игроков, причем продолжает работать даже при изменении размера списка.

# ПРИМЕЧАНИЕ 
# 
# В квадратные скобки, определяющие срез, можно добавить третье значение. Если оно присутствует, 
# то сообщает Python, сколько элементов следует пропускать при выборе элементов в заданном диапазоне.


# Перебор содержимого среза

# Если вы хотите перебрать элементы, входящие в подмножество элементов, используйте срез в цикле for. 
# В следующем примере программа перебирает первых трех игроков и выводит их имена как часть простого списка:

players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players)
print("Here are the first three players on my team:") # Вот первые три игрока моей команды:

for player in players[:3]:
    print(player.title())
print()

# Вместо того чтобы перебирать весь список игроков, Python ограничивается первыми тремя именами:
# Here are the first three players on my team:
# Charles
# Martina
# Michael

# Срезы очень полезны во многих ситуациях. Например, при создании компьютерной игры итоговый счет игрока может 
# добавляться в список после окончания текущей партии. После этого программа может получить три лучших результата игрока,
# отсор­тировав список по уменьшению и получив срез, содержащий только три элемента. При работе с данными срезы могут использоваться для обработки данных
# блоками заданного размера. Или при создании веб-приложения срезы можно использовать для постраничного вывода информации так, чтобы на каждой странице
# выводился соответствующий объем информации.


# Копирование списка

# Часто разработчик берет существующий список и на его основе создает совершенно новый. 
# Посмотрим, как работает копирование списков, и разберем одну ситуацию, в которой копирование списка может принести пользу.
# Чтобы скопировать список, создайте срез, содержащий весь исходный список без указания первого и второго индексов ([:]). 
# Эта конструкция создает срез, который начинается с первого элемента и завершается последним; в результате создается
# копия всего списка. Представьте, что вы создали список своих любимых блюд и теперь хотите создать отдельный список блюд, 
# которые нравятся вашему другу. Пока вашему другу нравятся все блюда из нашего списка, поэтому вы можете создать другой список,
# просто скопировав наш:

my_foods = ['pizza', 'falafel', 'carrot cake']
friend_foods = my_foods[:]
print("My favorite foods are:")
print(my_foods)
print("\nMy friend's favorite foods are:")
print(friend_foods)
print()

# Сначала создается список блюд my_foods. Затем создается другой список friend_foods. 
# Чтобы создать копию my_foods, программа запрашивает срез my_foods без указания индексов и сохраняет копию в friend_foods. 
# При выводе обоих списков становится видно, что они содержат одинаковые данные:
# My favorite foods are:
# ['pizza', 'falafel', 'carrot cake']
# My friend's favorite foods are:
# ['pizza', 'falafel', 'carrot cake']

# Чтобы доказать, что на самом деле речь идет о двух разных списках, добавим новое блюдо в каждый список и покажем, 
# что каждый из них отслеживает любимые блюда человека:

my_foods = ['pizza', 'falafel', 'carrot cake']
friend_foods = my_foods[:]
my_foods.append('cannoli')
friend_foods.append('ice cream')
print("My favorite foods are:")
print(my_foods)
print("\nMy friend's favorite foods are:")
print(friend_foods)
print()

# Исходные элементы my_foods копируются в новый список friend_foods. Затем в каждый список добавляется новый элемент: 
# 'cannoli' в my_foods, а 'ice cream' в friend_foods . После этого вывод двух списков наглядно показывает, что каждое
# блюдо находится в соответствующем списке:
# My favorite foods are:
# ['pizza', 'falafel', 'carrot cake', 'cannoli']
# My friend's favorite foods are:
# ['pizza', 'falafel', 'carrot cake', 'ice cream']

# Вывод показывает, что элемент 'cannoli' находится в списке my_foods, а элемент 'ice cream' — нет. 
# Видно, что 'ice cream' входит в список friend_foods, а элемент 'cannoli' — нет. 
# Если бы два этих списка просто совпадали, то их содержимое не различалось бы. 
# Например, вот что происходит при попытке копирования списка без использования среза:

my_foods = ['pizza', 'falafel', 'carrot cake']
# # Не работает:
friend_foods = my_foods
my_foods.append('cannoli')
friend_foods.append('ice cream')
print("My favorite foods are:")
print(my_foods)
print("\nMy friend's favorite foods are:")
print(friend_foods)
print()

# Вместо того чтобы сохранять копию my_foods в friend_foods, мы присваиваем переменной friend_foods значение переменной my_foods. 
# На самом деле этот синтаксис сообщает Python, что новая переменная friend_foods должна быть связана со списком, уже хранящимся в my_foods, 
# поэтому теперь обе переменные связаны с одним списком. В результате при добавлении элемента 'cannoli' в my_foods этот
# элемент также появляется в friend_foods. Аналогичным образом элемент 'ice
# cream' оказывается в обоих списках, хотя на первый взгляд был добавлен только в friend_foods.
# Вывод показывает, что оба списка содержат одинаковые элементы, а это совсем не то, что требовалось:
# My favorite foods are:
# ['pizza', 'falafel', 'carrot cake', 'cannoli', 'ice cream']
# My friend's favorite foods are:
# ['pizza', 'falafel', 'carrot cake', 'cannoli', 'ice cream']

# ПРИМЕЧАНИЕ

# Если какие-то подробности в этом примере кажутся непонятными, то не огорчайтесь.
# Если при работе с копией списка происходит что-то непредвиденное, убедитесь в том,
# что копируете список с помощью среза, как мы делали в первом примере.
